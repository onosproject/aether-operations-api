// SPDX-FileCopyrightText: 2022-present Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"flag"
	"fmt"
	"github.com/golang/glog"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"strings"
)

const indent = "  "

type GQLField struct {
	name      string
	fieldType string
	isList    bool
	required  bool
}

type GQLType struct {
	name   string
	fields []GQLField
}

type Schema struct {
	Types []GQLType
}

func main() {
	//DEBUG settings (uncomment to enable logs)
	flag.Set("logtostderr", "true")
	flag.Set("stderrthreshold", "WARNING")
	flag.Set("v", "2")

	flag.Parse()
	defer glog.Flush()

	schema := &Schema{}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			parseFile(f, schema)
		}
		generateSchema(gen, gen.Files[0], *schema)
		return nil
	})
}

func generateSchema(gen *protogen.Plugin, file *protogen.File, schema Schema) *protogen.GeneratedFile {
	filename := "schema.graphql"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("# Code generated by protoc-gen-graphql-schema. DO NOT EDIT.")

	for _, t := range schema.Types {

		// skip types with no fields
		if len(t.fields) == 0 {
			continue
		}

		g.P("type ", t.name, " {")

		for _, f := range t.fields {
			g.P(indent, strings.ToLower(f.name), ": ", fieldToType(f))
		}
		g.P("}")
		g.P()
	}
	return g
}

func parseFile(file *protogen.File, schema *Schema) error {
	for _, msg := range file.Messages {
		gt := GQLType{
			name:   string(msg.Desc.Name()),
			fields: []GQLField{},
		}

		for _, field := range msg.Fields {
			gf := GQLField{
				name:      strings.ToLower(string(field.Desc.Name())),
				fieldType: convertType(field),
				isList:    field.Desc.IsList(),
				required:  false, // TODO how to read annotations?
			}
			gt.fields = append(gt.fields, gf)
		}
		schema.Types = append(schema.Types, gt)
	}
	return nil
}

func fieldToType(f GQLField) string {
	// TODO add support for mandatory items

	if f.isList {
		return fmt.Sprintf("[%s]", f.fieldType)
	}

	return f.fieldType
}

func convertType(field *protogen.Field) string {
	glog.V(2).Infof("Converting type for field %s, kind is: %s (%d)", field.Desc.Name(), field.Desc.Kind(), field.Desc.Kind())

	if field.Desc.Name() == "ID" {
		return "ID"
	}

	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		tn := field.Desc.Message().Name()
		glog.V(2).Infof("Field %s is a a message: %s", field.Desc.Name(), tn)
		return string(tn)
	case protoreflect.Int32Kind, protoreflect.Int64Kind:
		return "Int"
	case protoreflect.FloatKind:
		return "Float"
	default:
		caser := cases.Title(language.English)
		return caser.String(field.Desc.Kind().String())
	}
}
